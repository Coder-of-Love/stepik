@Виктор Войтов
Как я вижу логику и описание решения данной задачи.


1. Если в условии идет речь о битах числа, то сразу нужно представлять число, поступающее на вход (в данной задачи это value) в двоичной системе счисления.
2. Если задача состоит в том, чтобы поменять знаки битов на противоположные, то сразу становится понятно, что необходимо использовать Исключающее ИЛИ (XOR) ' ^ ' и битовую маску, т.к только данный побитовый логический оператор ^ и битовая маска позволяет нам инвертировать (сменить состояние на противоположное) биты.

Битовая маска — определённые данные, которые используются для маскирования, т.е для выбора отдельных битов или полей из нескольких битов, из двоичной строки или числа. 

3. Для создания битовой маски, необходимо сделать логический сдвиг влево, а т.к по условию, нам нужно поменять знак всего 1 бита в числе на противоположный, то мы берем число 1 в двоичной системе счисления (00000001) и двигаем единичку на позицию, равную индексу бита, знак которого мы собираемся менять на противоположный (данный индекс поступает на вход int bitIndex). Cинтаксис выглядит так:

1 << bitIndex;

Конкретно в данном примере указано, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32), что является не верным, биты всегда нумеруются с 0, поэтому bitIndex необходимо скорректировать. Иначе биты в числе value будут нумероваться с 0, а биты в битовой маске с 1. Просто с полученного на вход индекса (bitIndex) вычтем одну позицию (1):

1 << bitIndex - 1;

Теперь везде нумерация идет с 0-го индекса.

4. Итак, битовая маска у нас есть, теперь мы можем наложить её на наше число value и инвертировать с помощью уже известного (XOR) ' ^ ' и соответствующего синтаксиса.

value ^ 1 << bitIndex -1;

добавляем return:

return value ^ 1 << bitIndex -1;

В итоге, единичка нашей маски встает ровно под битом, знак которого мы хотим инвертировать. С помощью побитового оператора ^ меняем знак бита на противоположный и возвращаем новое число.